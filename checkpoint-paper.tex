\documentclass[conference]{IEEEtran}

\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

\usepackage{cite, url}
% Enable the following line if you want highlighted hyperlink to citation and references
%\usepackage{hyperref}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}

\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Transaction Finality through Ledger Checkpoints 
	\thanks{This research is funded by KONA Software Lab, Limited.}
}

\author{
	\IEEEauthorblockN{Ratul Antik Das}
	\IEEEauthorblockA{\textit{Research and Development} \\
	\textit{Kona Software Lab}\\
		Dhaka, Bangladesh \\
		ratul.antik@konasl.com}
	\and		
	\IEEEauthorblockN{Md. Muhaimin Shah Pahalovi}
	\IEEEauthorblockA{\textit{Research and Development} \\
	\textit{Kona Software Lab}\\
		Dhaka, Bangladesh \\
		muhaimin.shah@konasl.com}		
	\and
	\IEEEauthorblockN{Muhammad Nur Yanhaona}
	\IEEEauthorblockA{\textit{Research and Development} \\
	\textit{Kona Software Lab}\\
		Dhaka, Bangladesh \\
		nur.yanhaona@konasl.com}
}
\maketitle

\begin{abstract}
Reversal of transactions due to blockchain ledger reorganization has become a major hindrance for public blockchain technologies adoption in real-world business and financial applications. Since a typical real-world product, service, or agreement cannot be backtracked; associated transactions in the blockchain ledger must also be final. This paper describes and analyzes the transaction finality solution for our proof of work (PoW) blockchain network, the Kona Blockchain Platform. Although designed for our specific platform, the ideas from the solution can be easilly adapted to achieve transaction finality in existing public blockchain networks. This paper also discusses how this can be done. To the best of our knowledge, ours is the first solution for transaction finality for blockchain networks incentivised exclusively by PoW mining.    
\end{abstract}

\begin{IEEEkeywords}
Computer Networks, peer-to-peer computing, distributed information systems
\end{IEEEkeywords}

\input{introduction.tex}

\input{related-work.tex}

\input{pow-incentive.tex}    

\section{Problem Modeling}
\label{s-model}
From the discussion of Section \ref{s-incentive}, we understand that the goal of the checkpoint protocol is to achieve a network-wide consensus about an irreversible and unique state of the blockchain ledger at deterministic intervals. We also understand that at the end of a checkpoint interval, there might be many miners holding different blockchain ledgers that are valid candidates to be the next checkpoint and many who are lagging behind. If we call the formers, \textit{Front-runners}, the qualitative goal of the checkpoint protocol should be as follows:

\begin{quote}
\textbf{Fairly select} a single ledger version from the front-runners \textbf{without censoring} the lagging behind miners and ensure \textbf{unaffected progression} of PoW block mining after the selection.  
\end{quote}

Our approach to the aforementioned highlighed objectives is to establish each checkpoint based on a $51\%$ majority voting by the currently active network peers on the chains of the front-runners who reached the checkpoint candidacy state the earliest. The evidence of checkpoint selection is included in the winning chain as a checkpoint block and the proceeds for mining the checkpoint block is distributed to the peers voted to support it. Here a balot is casted for a candidate by solving PoW puzzles on its chain state.

Assume there are total $N$ active peers in the blockchain network and the current state of the local blockchain ledger version of peer $i$ is represented as follows:
\begin{equation*}
\begin{split}
	BS_i(h, l, t, c) & = i^{th}\ peer's\ state,\ where \\
	h & = current\ header\ block\ hash \\
	l & = length\ of\ the\ blockchain \\
	t & = header\ block\ mining\ time \\
	c & = last\ checkpoint\ block\ hash	 
\end{split}
\end{equation*}
Further, let $BS_i^h, BS_i^l, BS_i^t, BS_i^c$ denote the individual attributes of $i^{th}$ peer's state and $BS_i^h(n)$, $BS_i^t(n)$ refer to the header block hash and mining time when the ledger length was $n$. In addition, let $\Lambda(h)$ returns the length of the blockchain ledger and $\mathcal{T}(h)$ the time when the block with hash $h$ was mined by anyone. Finally, let $C$ denotes the set of checkpoints. Then the objective of our checkpoint protocol is to maintain the following invariants as true for all currently active network peers:
\begin{equation}
\label{e-1}
BS_i^c = BS_j^c,\ \forall i \neq j\ \&\ i.j \in N
\end{equation}
\begin{equation}
\label{e-2}
\mathcal{T}(c) = \{\min_{i \in N}(\mathcal{T}(BS_i^h(l))) \mid l = \Lambda(c)\},\ \forall c \in C  
\end{equation}
\begin{equation}
\label{e-3}
\frac{\sum_i^N{\{1 \mid BS_i^h(l) = c,\ l = \Lambda(c)}\}}{N} \geq .51,\ \forall c \in C  
\end{equation}

Invariant \ref{e-1} says that all active network peers advance their ledger versions from a common check-pointed state, Invariant \ref{e-2} ensures that each checkpoint is selected among the ledger versions that receached the checkpoint candidacy state the earliest, finally, Invariant \ref{e-3} dictates that the candidate ledger version that gains $51\%$ majority support (i.e., synchronized by the majority) becomes the checkpoint.

A prerequisite to maintaining these invariant is to determine the value of $N$: the number of active peers in the network. In a purely peer-to-peer blockchain network no peer has an accurate estimate of the size of the currently active peer population. Thus we introduce a set of \textit{support service} nodes for active network population estimation. Addresses of these nodes are known to the mining peers. Support service nodes form a distributed population status estimation service. Each mining peer exchanges periodic heartbeat messages with random support nodes. To be considered currently active and eligible for participation in the upcoming checkpoint consensus protocol, a peer must have exchanged a heartbeat with some support node within a defined time window, we call the \textit{keep-alive time interval}. Assume the timestamp of latest heartbeat message of Peer $i$ is $H_i^t$, the keep-alive time interval is $\Delta$, and the network time of the distributed support service is $\Upsilon$. Then the rule for estimating $N$ is as follows:  
\begin{equation}
\label{e-4}
N = \sum_{i = 0}^{i = \infty}{1 \mid \Upsilon - H_i^t \leq \Delta}
\end{equation}
The support service also seals the checkpoint block by signing it once a majority consensus about the winning ledger version is reached. This seal is needed to ensure that even if the entire population of the active mining peers is replaced, new peers cannot revert a check-pointed state. A sealed checkpoint block is a $7$-tuple of the form $\langle \zeta_h, \zeta_c, \zeta_t, \zeta_e, \zeta_v, \zeta_i \rangle$ with the following interpretation:
\begin{equation*}
\begin{split}
	\zeta_h & = the\ block\ hash\ of\ the\ check\-pointed\ ledger\ state \\
	\zeta_c & = the\ current\ checkpoint\ interval\ counter \\
	\zeta_t & = the\ timestamp\ of\ the\ checkpoint\ block \\
	\zeta_e & = evidence\ that\ the\ estimation\ of\ N\ is\ accurate \\
	\zeta_v & = evidence\ that\ majority\ supported\ the\ checkpoint \\
	\zeta_i & = next\ checkpoint\ interval\ length
\end{split}
\end{equation*}

$\zeta_c$ and $\zeta_t$ ensure that the support service cannot regress to an earlier state of the blockchain and resume checkpoint sealing from there, and $\zeta_i$ makes provision for dynamic adjustments of the checkpoint interval.

Note that all attributes of Peer $i$'s ledger state are self-evident except for $BS_i^t$: the mining time of the header block. The peers of a blockchain network are only loosely time-synchronized and a mining peer can advance its clock (within a limit) to gain advantage in the checkpoint selection process. To tackle arbitrary adjustments of the block mining time, $BS_i^t$ is derived from Peer $i$'s heartbeat message timing with support nodes. Assume that, heartbeat message sequence is $1 \cdots M$.                   

\section{Checkpoint Algorithm}
\label{s-algorithm}

\section{Fitness Analysis}
\label{s-analysis}

\section{Implementation Concerns}
\label{s-implementation}

\section{Conclusion}
\label{s-conclusion}
\subsection{Future Work}
 
\bibliographystyle{plain}
\bibliography{references.bib}

\end{document}
