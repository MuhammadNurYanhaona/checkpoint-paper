\documentclass[conference]{IEEEtran}

\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

\usepackage{cite, url}
% Enable the following line if you want highlighted hyperlink to citation and references
%\usepackage{hyperref}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}

\usepackage{cases}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

% for code import
\usepackage{listings}
\usepackage{alltt}
\usepackage[utf8]{inputenc}
\usepackage{fancyvrb}
\usepackage{array}
\usepackage{colortbl}
\usepackage{ctable}
\usepackage{url}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{setspace}

\lstdefinelanguage{pseudo} {
                morekeywords={func},
                morekeywords={[2]if, while, for, else, break, return, in},
                morekeywords={[3]true, false, nil},
                morekeywords={[4]async},
                sensitive=true,
                morecomment=[l]{//}
}

\lstset{language=pseudo,
                basicstyle={\scriptsize\singlespacing},
                keywordstyle={\footnotesize\itshape\color[rgb]{0.1,0.1,0.9}},
                keywordstyle=[2]{\footnotesize\itshape\color[rgb]{0.9,0.1,0.1}},
                keywordstyle=[3]{\itshape\color[rgb]{0.1,0.5,0.1}},
                keywordstyle=[4]{\bf\itshape\color[rgb]{0.2,0.5,0.9}},
                numbers=left,
                tabsize=4,
                numbersep=4pt,
                basewidth=0.48em,
                commentstyle=\color[rgb]{0.1,0.4,0.1},
                xleftmargin=0.3cm,
                captionpos=b
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Transaction Finality through Ledger Checkpoints 
	\thanks{This research is funded by KONA Software Lab, Limited.}
}

\author{
	\IEEEauthorblockN{Ratul Antik Das}
	\IEEEauthorblockA{\textit{Research and Development} \\
	\textit{Kona Software Lab}\\
		Dhaka, Bangladesh \\
		ratul.antik@konasl.com}
	\and		
	\IEEEauthorblockN{Md. Muhaimin Shah Pahalovi}
	\IEEEauthorblockA{\textit{Research and Development} \\
	\textit{Kona Software Lab}\\
		Dhaka, Bangladesh \\
		muhaimin.shah@konasl.com}		
	\and
	\IEEEauthorblockN{Muhammad Nur Yanhaona}
	\IEEEauthorblockA{\textit{Research and Development} \\
	\textit{Kona Software Lab}\\
		Dhaka, Bangladesh \\
		nur.yanhaona@konasl.com}
}
\maketitle

\begin{abstract}
Reversal of transactions due to blockchain ledger reorganization has become a major hindrance for public blockchain technologies adoption in real-world business and financial applications. Since a typical real-world product, service, or agreement cannot be backtracked; associated transactions in the blockchain ledger must also be final. This paper describes and analyzes the transaction finality solution for our proof of work (PoW) blockchain network, the Kona Blockchain Platform. Although designed for our specific platform, the ideas from the solution can be easilly adapted to achieve transaction finality in existing public blockchain networks. This paper also discusses how this can be done. To the best of our knowledge, ours is the first solution for transaction finality for blockchain networks incentivised exclusively by PoW mining.    
\end{abstract}

\begin{IEEEkeywords}
Computer Networks, peer-to-peer computing, distributed information systems
\end{IEEEkeywords}

\input{introduction.tex}

\input{related-work.tex}

\input{pow-incentive.tex}    

\input{problem-model.tex}

\section{Checkpoint Algorithm}
\label{s-algorithm}
The general description of the checkpoint protocol is as follows:
\begin{enumerate}
\item If a miner, $f$, reaches the checkpoint candidacy state, it creates a voting token $t_f(0)$ (0 representing the token delegation depth) from its latest heartbeat acknowledgement that proves its  $BS_f^t$.
\item For each neighbor $n$, $f$ creates a time-stamped sub-token $t_f^{n}(1)$ dedicated for $n$ and requests a vote. This initiates a checkpoint consensus voting round.
\item A network peer $p$ evaluates all the voting requests, $t_{f_i}^{n}(d_{f_i})$s, it has received, validates the blockchain ledgers of corresponding candidates, determines voting for which candidate maximises its own profit, then casts an encoded vote for that candidate, $f_c$, by sending a payload with its next heartbeat message to the support service. Peer $p$ receives a vote acceptance acknowledgement $VA_p^t$ in return.
\item A front-runner miner $f$ makes its own encoded vote from $t_f(0)$ and registers the vote after it receives acceptance notifications from some neighbors or after a maximum waiting time.
\item Any peer $p$ who has voted keeps reaching out for more lagging behind neighbors by sending them voting sub-tokens made of its own $t_{f_c}^{p}(d_{f_c})$ and $VA_p^t$.
\item Until the end of the voting round, peers can keep changing their votes as they hear of better alternative to their current choice.   
\item At the end of the voting round, peers reveal their vote to support service by supplying the decoding key for their encoded vote with their next heartbeats.
\item If there is a single majority, support service supplies the sealing materials for the checkpoint block that the wining majority mines. The remaining others sychronize their ledgers with the majority and everyone switches back to the block mining phase.
\item If there is no single majority then some inferior candidates are filtered using a universally known, deterministic, and fair criteria. A new voting round begins with fewer candidates. The cycle continues in this manner until a single majority consensus is reached.                              
\end{enumerate}

Listing \ref{miner-algo} presents a reducted pseudo-code of the network peers' algorithm for the checkpoint consensus protocol. The pseudo-code does not show any error processing or malicious behavior detection.

\lstset{caption=A miner's perspective of the checkpoint protocol, label=miner-algo}
\lstinputlisting{miners-perspective.go} 

Note that a voting round is self-terminating. Each miner individually determines when to stop voting and reveal its final candidate of choice based on a support service clock counter (\textit{Line 83}). In addition, the whole consensus process is guaranteed to converge as each voting round reduces the front-runner candidates count and ensures that all honest network peers get to know about all remaining candidates. We will discuss the termination and convergence of the algorithm along with other properties in the next section.

Listing \ref{support-algo} presents a reducted pseudo-code of the support service side of the checkpoint algorithm. The vote revelation step and error processing related logic are omitted in the listing.

\lstset{caption=Support service's perspective of the checkpoint protocol, label=support-algo}
\lstinputlisting{support-service-perspective.go}

Any heartbeat exchange with the support service involves solving a new PoW puzzle. This is done to avoid a denial of service attack on the support service by frequent heartbeats \cite{Back02hashcash}. In addition, changing an existing vote involves solving increasingly more difficult PoW challenge (\textit{Line} \textit{29} and \textit{114}). This strategy compels rational miners to be prudent about their vote change decision. 

The support service alternate between different heartbeat processors (\textit{Line 50, 61, 81}, and \textit{89}) based on an internal clock and the state of the ongoing checkpoint consensus process. In particular, the first voting round remains open for $\frac{N}{2}$ clock ticks (\textit{Line 51}) and the remaining rounds run for $N - 1$ clock ticks (\textit{Line 76}). Successive ticks of the internal clock should provide enough time for a blockchain ledger synchronization between a pair of interacting network peers and the \textit{activation window}, $\Omega$, of \textit{Line 60} should be large enough to allow all network peers to exchange at least one heartbeat message with some support service node.

The support service freeze the checkpoint candidate list $\Omega$ time after locally initiating the checkpoint protocol (\textit{Line 47}). Observant readers will notice that it does so without even knowing the candidates, as all votes are encoded. What this operation does is finalize the list of peers to be probed by lagging behind miners who did not vote yet.    
        
\section{Fitness Analysis of Checkpoint Protocol}
\label{s-analysis}
In this section, we discuss various properties of the checkpoint protocol. Throughout this discussion we assume that $51\%$ of the network peers are honest.

Since mining peers determine the end of a voting round based on a support service clock counter, it is guaranteed that each voting round will terminate at deterministic time. What remains to be proven is that the support service can unequivocally determine that some front runner peers have reached the checkpoint candidacy state, its strategy to freeze the front-runner checkpoint candidate set (\textit{Line 47}) is not exclusionary, and its round termination counter provides enough time for all rational miners to make a final voting decision in each round. Following lemmas address these concerns:     

\begin{lemma}
\label{l-proto-init}
The support service can determine the initiation of a checkpoint consensus voting process without knowing the identities of the honest miners.  
\end{lemma}
\begin{proof}
The particular problem with checkpoint protocol initiation detection is that the front-runner miners launch the consensus voting process by directly requesting their neighbors for vote without informing the support service anything about their ledgers' checkpoint candidacy state. Keeping the support service oblivious of the front-runners is important to avoid introducing any support service induced bias on the checkpoint Invarient \ref{e-2} through $BS_i^t$ values. This in turns create the problem that malicious peers can pretend that someone has reached checkpoint candidacy state by registering encoded checkpoint vote with support service even when there is no valid checkpoint candidate.

However, since an honest miner will always verify the ledger of a peer requesting checkpoint vote before making a voting decision, a colluding party of lagging-behind malicious miners cannot convince an honest miner to ever vote in their favor. Since the honest miners are the majority, an invalid checkpoint candidate can never reach the consensus. So eventually, some honest miners will become front-runner and one or more honest miners will register their checkpoint vote with the support service. If $50\%$ of the currently active miners casted ballot for checkpoint then there must be at least one honest miner who is either a front-runner or containing a ledger synchronized from a valid front-runner checkpoint candidate. Therefore, support service can kick off its checkpoint vote processing rounds without doubt after receiving that many votes. 
\end{proof}

\begin{lemma}
\label{l-cand-list}
No new checkpoint candidate front-runner miner with non-zero chance to win consensus for its ledger can appear after $\Omega$ time of support service's protocol initiation declaration.     
\end{lemma}
\begin{proof}
By the time the support service declares initiation of the checkpoint protocol, at least one honest miner has registered vote in favor of some valid checkpoint candidate. Consider the worst case of exactly one honest vote. Suppose that vote is casted in favor of front-runner miner $f$. Finally, for a contradiction, assume the first vote for another valid candidate $f^\prime$ can appears after $\Omega$ time of protocol initation declaration. 

Note that $\Omega$ is large enough for all miners to exchange one heartbeat with the support service. Hence any vote casted for a previously unseen alternative front-runner candidate $f^\prime$ after $\Omega$ time of protocol initiation declaration must satisfy $BS_f^t \leq BS_{f^\prime}^t$. According to \textit{Invarient \ref{e-2}} of check-pointing, $f^\prime$ cannot win consensus. A contradiction.  
\end{proof}

\begin{lemma}
\label{l-round-time}
$\frac{N}{2}$ support service timer ticks are enough for any rational miner to make a final choice about front-runner checkpoint candidates in all consensus voting rounds.   
\end{lemma}


\section{Implementation Concerns}
\label{s-implementation}

\section{Conclusion}
\label{s-conclusion}
\subsection{Future Work}
 
\bibliographystyle{plain}
\bibliography{references.bib}

\end{document}
